# CI/CD - Основы виртуализации и контейнеризации

* [Продвинутые возможности Jenkins](#Продвинутые-возможности-Jenkins)
* [CI/CD в Kubernetes](#CI/CD-в-Kubernetes)
* [GitOps](#GitOps)
* [Основные понятия](#Основные-понятия)

## <a id="Продвинутые-возможности-Jenkins">Продвинутые возможности Jenkins</a>

```txt
1 - Multi-branch pipelines.
2 - Scripted pipelines, отличия от декларативного синтаксиса.
3 - Что такое Jenkins Shared Libraries.
4 - Сценарии использование Jenkins Shared Libraries.
5 - Разработка Jenkins Shared Libraries.
6 - Настройка Jenkins.
7 - Разграничение прав доступа в Jenkins.
```

### Notice-1

```txt
1 - Что такое Multi-branch пайплайн?

->  Мульти-бранч пайплайн в Jenkins - это тип пайплайна,
    который позволяет автоматически создавать пайплайны
    для каждой ветки в репозитории. Это означает, что
    Jenkins будет обнаруживать все ветки в репозитории и
    создавать отдельный пайплайн для каждой из них.

    Например, если у вас есть репозиторий с ветками
    master, dev, feature/new-feature и release/1.0,
    Jenkins создаст отдельный пайплайн для каждой из этих веток
    
    - master пайплайн будет запускаться при каждом
    коммите в основную ветку и будет выполнять сборку
    и тестирование основного кода.
    - dev пайплайн будет запускаться при каждом
    коммите в ветку разработки и будет выполнять сборку
    и тестирование кода в разработке.
    - feature/new-feature пайплайн будет запускаться
    при каждом коммите в ветку новой функции и будет
    выполнять сборку и тестирование кода новой функции.
    - release/1.0 пайплайн будет запускаться при каждом
    коммите в ветку релиза и будет выполнять сборку и
    тестирование кода релиза.

    Это позволяет автоматизировать процесс сборки и
    тестирования для каждой ветки, что особенно полезно при
    использовании GitFlow или других моделей ветвления. Кроме
    того, мульти-бранч пайплайны позволяют легко отслеживать
    статус сборки и тестирования для каждой ветки, что упрощает
    процесс управления кодом.

    В Jenkins мульти-бранч пайплайны можно настроить с помощью
    плагина "Multibranch Pipeline" и конфигурации файла
    Jenkinsfile в корне репозитория. Файл Jenkinsfile содержит
    описание пайплайна и может быть написан на языке Groovy
    или в формате YAML.

    Мульти-бранч пайплайны также поддерживают следующие функции:
    - Автоматическое обнаружение веток и создание пайплайнов
    - Поддержка различных типов репозиториев, включая Git,
    SVN и Mercurial
    - Возможность настройки пайплайна для каждой ветки
    - Возможность использования различных агентов для
    выполнения пайплайна
    - Поддержка параллельного выполнения пайплайнов
```

### Intern-1

```txt
1 - Какие есть преимущества и недоставки jenkins scripted
    pipeline по сравнению с декларативными? Как выбрать
    тот или иной  стиль для своего проекта?

->  Преимущества Scripted Pipeline:
    - Больше гибкости: Scripted Pipeline позволяет
    использовать полный потенциал Groovy, что дает
    больше возможностей для создания сложных пайплайнов.
    - Легче отладка: Scripted Pipeline позволяет
    использовать стандартные инструменты отладки
    Groovy, что упрощает процесс отладки пайплайна.
    - Больше контроля: Scripted Pipeline дает больше
    контроля над процессом сборки и тестирования, что
    позволяет создавать более сложные и специализированные
    пайплайны.

    Недостатки Scripted Pipeline:
    - Больше сложности: Scripted Pipeline требует
    больше знаний Groovy и Jenkins API, что может
    быть сложно для начинающих.
    - Больше ошибок: Scripted Pipeline более подвержен
    ошибкам, поскольку требует ручного написания кода.
    - Меньшая поддержка: Scripted Pipeline не поддерживает
    все функции Jenkins, что может ограничить его возможности.

    Преимущества Declarative Pipeline:
    - Легче: Declarative Pipeline более прост в
    использовании и требует меньше знаний Groovy и
    Jenkins API.
    - Меньше ошибок: Declarative Pipeline менее
    подвержен ошибкам, поскольку использует более простой
    синтаксис и автоматически проверяет код.
    - Больше поддержки: Declarative Pipeline
    поддерживает все функции Jenkins, что дает больше
    возможностей для создания пайплайнов.

    Недостатки Declarative Pipeline:
    - Меньше гибкости: Declarative Pipeline менее гибок,
    чем Scripted Pipeline, поскольку использует более простой
    синтаксис.
    - Меньше контроля: Declarative Pipeline дает меньше
    контроля над процессом сборки и тестирования, что может
    быть ограничением для сложных проектов.

    Как выбрать стиль для своего проекта:
    - Начните с Declarative Pipeline: Если вы новичок в
    Jenkins или не имеете опыта работы с Groovy, начните
    с Declarative Pipeline. Это более простой и интуитивно
    понятный синтаксис.
    - Используйте Scripted Pipeline для сложных проектов:
    Если ваш проект требует более сложного пайплайна или
    специализированных функций, используйте Scripted Pipeline.
    Это дает больше гибкости и контроля над процессом сборки
    и тестирования.
    - Используйте Declarative Pipeline для простых проектов:
    Если ваш проект простой и не требует сложного пайплайна,
    используйте Declarative Pipeline. Это более простой и
    быстрый способ создания пайплайна.
```

```txt
2 - Что такое Jenkins Shared Library?

->  Jenkins Shared Library - это механизм, позволяющий
    хранить и использовать повторно код Groovy в нескольких
    пайплайнах Jenkins. Это позволяет создавать библиотеки
    кода, которые можно использовать в нескольких проектах,
    что упрощает процесс управления кодом и повышает
    производительность команды разработки.

    Shared Library позволяет хранить код Groovy в
    отдельном репозитории, который можно использовать в
    нескольких пайплайнах Jenkins. Это дает следующие преимущества:
    - Переиспользование кода: Shared Library позволяет
    переиспользовать код Groovy в нескольких пайплайнах,
    что уменьшает количество дублирующегося кода и упрощает
    процесс управления кодом.
    - Упрощение обновления кода: Shared Library позволяет
    обновлять код Groovy в одном месте, что автоматически
    обновляет все пайплайны, которые используют эту библиотеку.
    - Увеличение производительности: Shared Library позволяет
    создавать более сложные и специализированные пайплайны,
    что повышает производительность команды разработки.

    Shared Library можно использовать для хранения
    различных типов кода, таких как:
    - Функции: Shared Library можно использовать для
    хранения функций Groovy, которые можно использовать в
    нескольких пайплайнах.
    - Классы: Shared Library можно использовать для
    хранения классов Groovy, которые можно использовать в
    нескольких пайплайнах.
    - Пайплайны: Shared Library можно использовать
    для хранения пайплайнов Groovy, которые можно использовать
    в нескольких проектах.

    Пример использования Shared Library:
    shared-library.groovy
    // функция для сборки проекта
    def buildProject() {
    // код для сборки проекта
    }

    // функция для тестирования проекта
    def testProject() {
    // код для тестирования проекта
    }

    jenkinsfile
    // использование Shared Library
    @Library('shared-library') _

    // вызов функции для сборки проекта
    buildProject()

    // вызов функции для тестирования проекта
    testProject()

    В этом примере Shared Library хранит две
    функции: buildProject() и testProject(). Эти функции
    можно использовать в нескольких пайплайнах, что упрощает
    процесс управления кодом и повышает производительность
    команды разработки.

    Чтобы использовать Shared Library, необходимо:
    - Создать репозиторий: Создайте отдельный репозиторий
    для хранения кода Groovy.
    - Добавить код: Добавьте код Groovy в репозиторий.
    - Настроить Jenkins: Настройте Jenkins для использования
    Shared Library.
    - Использовать Shared Library: Используйте Shared Library
    в своих пайплайнах.
```

```txt
3 - Как подключить Jenkins Shared Library к проекту?

->  1 - Создать репозиторий для Shared Library
        Создайте отдельный репозиторий для хранения кода
        Shared Library. Это может быть Git-репозиторий или
        любой другой тип репозитория, поддерживаемый Jenkins.

    2 - Добавить код в репозиторий
        Добавьте код Shared Library в репозиторий. Это
        может быть Groovy-код, который содержит функции,
        классы или пайплайны.
    
    3 - Настроить Jenkins
        Настройте Jenkins для использования Shared Library.
        Для этого необходимо выполнить следующие шаги:
        - Добавить репозиторий: Добавьте репозиторий Shared
        Library в Jenkins. Для этого необходимо перейти в
        раздел "Manage Jenkins" -> "Configure System" и
        добавить репозиторий в список "Git Repositories".
        - Настроить Shared Library: Настройте Shared Library
        в Jenkins. Для этого необходимо перейти в раздел
        "Manage Jenkins" -> "Configure System" и добавить
        Shared Library в список "Shared Libraries".

    4 - Подключить Shared Library к проекту
        Подключите Shared Library к проекту. Для этого необходимо
        выполнить следующие шаги:
        - Добавить Shared Library в Jenkinsfile: Добавьте
        Shared Library в Jenkinsfile проекта. Для этого
        необходимо добавить строку @Library('shared-library') _
        в начало Jenkinsfile.
        - Использовать Shared Library: Используйте Shared
        Library в проекте. Для этого необходимо вызвать
        функции или классы из Shared Library в Jenkinsfile.

        // Jenkinsfile
        @Library('shared-library') _

        // вызов функции из Shared Library
        buildProject()
    5 - Проверить подключение
        Проверьте подключение Shared Library к проекту.
        Для этого необходимо запустить пайплайн проекта и
        проверить, что функции или классы из Shared Library
        вызываются правильно
```

### Advanced-1

```txt
1 - Как создать свою Shared Library?
    В каких случаях это может пригодится?

->  Создание Shared Library
    Чтобы создать свою Shared Library, необходимо
    выполнить следующие шаги:
    - Создать репозиторий: Создайте отдельный репозиторий
    для хранения кода Shared Library. Это может быть
    Git-репозиторий или любой другой тип репозитория,
    поддерживаемый Jenkins.
    - Добавить код: Добавьте код Shared Library в репозиторий.
    Это может быть Groovy-код, который содержит функции,
    классы или пайплайны.
    - Настроить структуру: Настройте структуру репозитория
    Shared Library. Это может включать создание папок и файлов
    для хранения кода, а также настройку файла jenkinsfile
    для определения пайплайна.
    - Тестировать: Тестировать Shared Library, чтобы убедиться,
    что она работает правильно.

    shared-library/
    ├── src/         папка для хранения кода Shared Library.
    │   ├── groovy/  папка для хранения Groovy-кодов.
    │   │   ├── MyFunction.groovy  файл, содержащий функцию myFunction
    │   │   └── MyPipeline.groovy  файл, содержащий пайплайн myPipeline
    │   └── resources/          папка для хранения ресурсов
    │       └── my-resource.txt файл, содержащий ресурс
    ├── vars/                   папка для хранения переменных
    │   └── my-vars.groovy      файл, содержащий переменные
    ├── jenkinsfile             файл, содержащий пайплайн Shared Library
    └── README.md

    Shared Library может пригодиться в следующих случаях:
    - Переиспользование кода: Shared Library позволяет
    переиспользовать код в нескольких пайплайнах, что
    уменьшает количество дублирующегося кода.
    - Упрощение обновления кода: Shared Library позволяет
    обновлять код в одном месте, что автоматически обновляет
    все пайплайны, которые используют эту библиотеку.
    - Увеличение производительности: Shared Library позволяет
    создавать более сложные и специализированные пайплайны,
    что повышает производительность команды разработки.
    - Создание повторно используемых компонентов: Shared
    Library позволяет создавать повторно используемые
    компоненты, которые можно использовать в нескольких
    пайплайнах.
    - Упрощение управления кодом: Shared Library позволяет
    упростить управление кодом, поскольку все компоненты
    хранятся в одном месте.
```

```txt
2 - Как ограничивать доступ к проектам/джобам в Jenkins?

->  Jenkins предоставляет несколько способов ограничить доступ
    к проектам/джобам, чтобы обеспечить безопасность и контроль
    над доступом к ресурсам. Вот некоторые из них:
    - Аутентификация: Jenkins поддерживает аутентификацию
    пользователей с помощью различных методов, таких как LDAP,
    Active Directory, GitHub и другие. Это позволяет ограничить
    доступ к проектам/джобам только для авторизованных пользователей.
    - Авторизация: Jenkins поддерживает авторизацию пользователей
    с помощью различных методов, таких как роль-based access
    control (RBAC) и attribute-based access control (ABAC).
    Это позволяет ограничить доступ к проектам/джобам только
    для пользователей с определенной ролью или атрибутами.
    - Группы пользователей: Jenkins позволяет создавать группы
    пользователей и назначать им права доступа к проектам/джобам.
    Это позволяет ограничить доступ к проектам/джобам только
    для пользователей, входящих в определенные группы.
    - Права доступа: Jenkins позволяет назначать права доступа
    к проектам/джобам для пользователей или групп пользователей.
    Это позволяет ограничить доступ к проектам/джобам только для
    пользователей с определенным уровнем доступа.
    - Маскировка проектов: Jenkins позволяет маскировать проекты/джобы,
    чтобы они были невидимы для пользователей, не имеющих доступа к ним.
    - Параметры безопасности: Jenkins позволяет настраивать параметры
    безопасности для проектов/джоб, такие как SSL/TLS и аутентификация
    через прокси.

    Чтобы ограничить доступ к проектам/джобам в Jenkins,
    необходимо выполнить следующие шаги:
    - Войти в Jenkins: Войдите в Jenkins с помощью
    учетной записи администратора.
    - Перейти в раздел "Manage Jenkins": Перейдите в раздел
    "Manage Jenkins" и выберите "Configure Global Security".
    - Настроить аутентификацию: Настройте аутентификацию
    пользователей с помощью одного из поддерживаемых методов.
    - Настроить авторизацию: Настройте авторизацию пользователей
    с помощью одного из поддерживаемых методов.
    - Создать группы пользователей: Создайте группы
    пользователей и назначьте им права доступа к проектам/джобам.
    - Назначить права доступа: Назначьте права доступа к
    проектам/джобам для пользователей или групп пользователей.
    - Маскировать проекты: Маскируйте проекты/джобы, чтобы
    они были невидимы для пользователей, не имеющих доступа к ним.

    // создание группы пользователей
    groups {
        developers {
            members {
                'john'
                'jane'
            }
        }
    }

    // конфигурация аутентификации
    securityRealm {
        ldap {
            server = 'ldap://example.com'
            rootDN = 'dc=example,dc=com'
            userSearchBase = 'ou=people'
            userSearchFilter = '(uid={0})'
        }
    }
```

```txt
3 - Что такое matrix based auth strategy?

->  Matrix Based Auth Strategy (Матричная стратегия
    аутентификации) - это метод аутентификации и авторизации
    пользователей в Jenkins, который позволяет управлять
    доступом к ресурсам на основе матрицы разрешений.

    В матричной стратегии аутентификации каждый пользователь
    или группа пользователей имеет свой набор разрешений, которые
    определяют, что он может делать в Jenkins. Разрешения
    представляют собой матрицу, в которой строки представляют
    пользователей или группы пользователей, а столбцы представляют
    ресурсы, к которым они имеют доступ.

    Принцип работы
    - Матричная стратегия аутентификации работает следующим
    образом:
    Определение разрешений: Администратор определяет
    разрешения для каждого пользователя или группы пользователей
    в матрице.
    - Аутентификация: Пользователь аутентифицируется в Jenkins
    с помощью учетной записи.
    - Авторизация: Jenkins проверяет разрешения пользователя или
    группы пользователей в матрице и определяет, имеет ли он доступ
    к ресурсу.
    - Доступ к ресурсу: Если пользователь или группа пользователей
    имеет доступ к ресурсу, Jenkins предоставляет ему доступ к ресурсу.

    Преимущества
    - Матричная стратегия аутентификации имеет следующие
    преимущества:
    - Гибкость: Матричная стратегия аутентификации позволяет
    управлять доступом к ресурсам на основе сложных правил и
    разрешений.
    - Масштабируемость: Матричная стратегия аутентификации может
    быть использована для управления доступом к ресурсам в крупных
    организациях.
    - Безопасность: Матричная стратегия аутентификации обеспечивает
    высокий уровень безопасности, поскольку доступ к ресурсам
    контролируется на основе разрешений.

    Конфигурация Матричная стратегия аутентификации может быть
    настроена в Jenkins с помощью плагина "Matrix Authorization Strategy".
    Для этого необходимо выполнить следующие шаги:
    - Установить плагин: Установите плагин "Matrix Authorization
    Strategy" в Jenkins.
    - Настроить матрицу: Настройте матрицу разрешений в Jenkins.
    - Присвоить разрешения: Присвойте разрешения пользователям
    или группам пользователей в матрице.

    // конфигурация матрицы разрешений
    matrixAuthorization {
        permissions {
            'hudson.model.Hudson.Administer' {
            'admin' {
            'allowed' = true
            }
        }
    ...
```

```txt
4 - Что такое Jenkins Sandbox?

->  Jenkins Sandbox - это виртуальная среда, которая позволяет
    запускать и тестировать Jenkins плагины и скрипты в изолированной
    среде, не влияя на основную систему Jenkins.

    Принцип работы
    Jenkins Sandbox работает следующим образом:
    - Создание виртуальной среды: Jenkins создает виртуальную среду,
    которая является копией основной системы Jenkins.
    - Запуск плагинов и скриптов: Плагины и скрипты запускаются в
    виртуальной среде, где они могут быть протестированы и отлажены.
    - Изоляция: Виртуальная среда изолирована от основной системы
    Jenkins, что позволяет избежать влияния на основную систему.

    Преимущества
    Jenkins Sandbox имеет следующие преимущества:
    - Безопасность: Jenkins Sandbox позволяет запускать плагины
    и скрипты в изолированной среде, что снижает риск влияния на
    основную систему.
    - Тестирование: Jenkins Sandbox позволяет протестировать
    плагины и скрипты в изолированной среде, что упрощает процесс тестирования.
    - Отладка: Jenkins Sandbox позволяет отладить плагины и
    скрипты в изолированной среде, что упрощает процесс отладки.

    Пример использования
    // пример использования Jenkins Sandbox
    def sandbox = new JenkinsSandbox()
    sandbox.start()

    // запуск плагина в виртуальной среде
    def plugin = new MyPlugin()
    sandbox.run(plugin)

    // тестирование плагина в виртуальной среде
    def test = new MyTest()
    sandbox.run(test)

    // отладка плагина в виртуальной среде
    def debugger = new MyDebugger()
    sandbox.run(debugger)

    sandbox.stop()

    Jenkins Sandbox можно конфигурировать с помощью файла
    jenkins.yaml. В этом файле можно указать параметры виртуальной
    среды, такие как размер памяти и количество процессоров.
    // пример конфигурации Jenkins Sandbox
    jenkins:
    sandbox:
        memory: 1024m
        cpus: 2
```

## <a id="CI/CD-в-Kubernetes">CI/CD в Kubernetes</a>

```txt
1 - Стратегии деплоя приложений в Kubernetes.
2 - Helm
```

### Notice-2

```txt
1 - Что такое Helm? Какую проблему он решает? 

->  Helm - это менеджер пакетов для Kubernetes, который упрощает
    процесс установки и управления приложениями в кластере Kubernetes.
    Он решает проблему сложности развертывания и управления приложениями в
    Kubernetes, предоставляя простой и удобный способ установки и
    обновления приложений.

    Helm позволяет:
    - Упаковывать приложения в повторно используемые пакеты (charts)
    - Управлять зависимостями и конфигурацией приложений
    - Упрощать процесс установки и обновления приложений
    - Обеспечивать повторяемость и предсказуемость развертывания приложений

    Это особенно полезно для крупных и сложных приложений, которые состоят
    из множества компонентов и требуют тщательной настройки. Helm помогает упростить
    процесс управления этими приложениями и сделать его более автоматизированным.
```

```txt
2 - Что такое Helm-чарт?

->  Helm-чарт (Helm Chart) - это упакованный пакет приложения, который содержит
    все необходимые ресурсы и конфигурации для развертывания приложения в
    кластере Kubernetes.

    Чарт включает в себя:
    - Манифесты Kubernetes (yaml-файлы), которые описывают ресурсы,
    необходимые для развертывания приложения, такие как деплойменты, сервисы,
    persistent volumes и т.д.
    - Шаблоны конфигурации, которые позволяют настраивать приложение во время
    установки
    - Зависимости и требования к ресурсам, которые необходимы для работы
    приложения
    - Документацию и инструкции по установке, которые помогают пользователям
    понимать, как устанавливать и использовать приложение
    - Версионирование, которое позволяет отслеживать изменения в чарте и
    управлять различными версиями приложения

    Чарты могут быть созданы для конкретного приложения или сервиса, и
    они могут быть легко распространены и установлены в кластере Kubernetes
    с помощью Helm. Это позволяет упростить процесс развертывания и управления
    приложениями в Kubernetes, а также обеспечивает повторяемость и
    предсказуемость развертывания.
```

### Intern-2

```txt
1 - Что такое values-файл в Helm?

->  Values-файл в Helm - это файл, который содержит пользовательские
    значения, которые используются для настройки чарта во время установки.
    Этот файл позволяет пользователю задавать значения для переменных, которые
    используются в шаблонах конфигурации чарта.

    Values-файл обычно имеет расширение .yaml или .yml и содержит
    ключ-значение пары, которые используются для настройки чарта.
    Например, values-файл может содержать значения для таких переменных,
    как:
    - Имя приложения
    - Версия приложения
    - Параметры конфигурации
    - Значения переменных окружения

    Во время установки чарта, Helm использует значения из values-файла для
    замены переменных в шаблонах конфигурации, что позволяет настроить чарт
    в соответствии с потребностями пользователя.
```

```txt
2 - Как использовать переменные в Helm-чартах?  

->  В Helm-чартах переменные можно использовать с помощью синтаксиса
    {{ .Values.имя_переменной }}. Этот синтаксис позволяет получить значение
    переменной из values-файла и использовать его в шаблонах конфигурации.

    metadata:
        name: {{ .Values.appName }}

    Также можно использовать функции шаблонизации, такие как default,
    required и lookup, чтобы работать с переменными в шаблонах конфигурации.

    metadata:
        name: {{ .Values.appName | default "myapp" }}
```

```txt
3 - Как использовать несколько values-файлов при деплое?

->  В Helm можно использовать несколько values-файлов при деплое, чтобы
    разделить конфигурацию на несколько файлов или чтобы использовать
    разные конфигурации для разных окружений.

    - helm install mychart --values values.yaml --values values-prod.yaml
    - helm install mychart -f values.yaml -f values-prod.yaml -f values-override.yaml
```

```txt
4 - Как переопределить при запуске деплоя с помощью
    Helm переменную из values-файла?

->  Чтобы переопределить переменную из values.yaml файла при запуске
    деплоя с помощью Helm, вы можете использовать флаг --set или --set-string
    в команде helm install или helm upgrade.

    helm install my-release my-chart --set image.tag=latest
    helm install my-release my-chart --set-string image.tag="latest-rc"
    helm install my-release my-chart --set image.tag=latest,replicaCount=3
    helm install my-release my-chart -f my-values.yaml

    Если у вас есть values-файл values.yaml с переменной myVariable и вы
    хотите переопределить ее значение на newValue при деплое, вы можете
    использовать следующую команду

    helm upgrade --install my-release . --set myVariable=newValue
    helm upgrade --install my-release . --set values.myVariable=newValue

    В Helm 3 --install и --upgrade объединены в один флаг --install
```

### Advanced-2

```txt
1 - Как перед запуском деплоя с помощью Helm посмотреть
    сгенерированные им манифесты?

->  Helm 2 

    helm install my-release my-chart --dry-run
    Флаг --dry-run используется для генерации манифестов Kubernetes
    без фактического применения их к кластеру. Это означает, что Helm
    будет генерировать манифесты, но не будет создавать ресурсы в кластере.

    helm install my-release my-chart --debug
    Флаг --debug используется для вывода дополнительной информации о
    процессе генерации манифестов и применения их к кластеру. Это означает,
    что Helm будет выводить подробную информацию о том, что происходит во
    время генерации и применения манифестов.
    
    helm install my-release my-chart --dry-run --output-dir ./manifests

    Helm 3
    helm template my-release my-chart
    helm template my-release my-chart --output-dir ./manifests
    helm template my-release my-chart --debug

    В Helm 3 команда helm install и helm upgrade больше не
    поддерживают флаг --dry-run
```

```txt
2 - Как откатиться на предыдущий релиз с помощью Helm?

->  kubectl rollout history
    kubectl rollout status 

    helm history RELEASE
    helm rollback <RELEASE>
    helm rollback my-release 

    Helm хранит историю релизов в кластере Kubernetes, поэтому вы можете
    откатиться на предыдущий релиз даже если вы удалили релиз с помощью
    команды helm uninstall
```

## <a id="GitOps">GitOps</a>

```txt
1 - Понятие GitOps, преимущества и недостатки подхода.
2 - Argo CD
```

### Notice-3

```txt
1 - Что такое GitOps? 

->  GitOps - это подход к управлению инфраструктурой и приложениями,
    который использует Git как основную систему управления конфигурацией.

    GitOps позволяет управлять инфраструктурой и приложениями как кодом,
    используя Git для хранения и управления конфигурацией

    GitOps основан на следующих принципах:
    - Git как основная система управления конфигурацией: Git используется
    для хранения и управления конфигурацией инфраструктуры и приложений.
    - Код как конфигурация: конфигурация инфраструктуры и приложений представлена
    в виде кода, который может быть изменен и управляем как любой другой код.
    - Автоматическое применение конфигурации: конфигурация инфраструктуры
    и приложений автоматически применяется после изменения кода.
    - Мониторинг и аудит: изменения конфигурации инфраструктуры и приложений
    отслеживаются и аудируются для обеспечения прозрачности и безопасности

    GitOps может быть использован для управления различными типами
    инфраструктуры и приложений, включая:
    - Контейнеризированные приложения: GitOps может быть использован
    для управления контейнеризированными приложениями, такими как Docker.
    - Клауд-инфраструктура: GitOps может быть использован для
    управления облачной инфраструктурой, такой как AWS или Azure.
    - Микросервисная архитектура: GitOps может быть использован
    для управления микросервисной архитектурой, такой как Kubernetes.

    GitOps предоставляет следующие преимущества:
    - Упрощенное управление конфигурацией
    - Автоматическое применение конфигурации
    - Повышенная прозрачность и безопасность
    - Улучшенная совместная работа

    Кроме того, GitOps может быть интегрирован с различными инструментами
    и технологиями, такими как:
    - CI/CD: GitOps может быть интегрирован с инструментами CI/CD,
    такими как Jenkins или GitLab CI/CD, для автоматизации процесса
    сборки и развертывания приложений.
    - Мониторинг: GitOps может быть интегрирован с инструментами
    мониторинга, такими как Prometheus или Grafana, для отслеживания
    производительности и состояния инфраструктуры и приложений.
    - Безопасность: GitOps может быть интегрирован с инструментами
    безопасности, такими как Vault или Kubernetes Secrets, для
    управления доступом и шифрования данных.

    В целом, GitOps является мощным инструментом для управления
    инфраструктурой и приложениями, который может помочь упростить
    процесс управления конфигурацией, повысить прозрачность и безопасность,
    и улучшить совместную работу.
```

### Intern-3

```txt
1 - Какие преимущества и недостатки он даёт?

->  GitOps - это подход к управлению инфраструктурой и приложениями
    с помощью Git. Основная идея GitOps заключается в том, чтобы
    использовать Git в качестве единого источника истины для
    конфигурации и управления инфраструктурой и приложениями.

    Преимущества GitOps:
    - Управление конфигурацией: GitOps позволяет хранить
    конфигурацию инфраструктуры и приложений в Git, что
    обеспечивает прозрачность, отслеживание изменений и
    управление версиями.
    - Автоматизация: GitOps позволяет автоматизировать
    процесс развертывания и обновления инфраструктуры и
    приложений, что снижает риск ошибок и увеличивает скорость
    выпуска.
    - Непрерывная интеграция и доставка: GitOps позволяет
    интегрировать процесс непрерывной интеграции и доставки
    (CI/CD) с Git, что обеспечивает автоматизированную сборку,
    тестирование и развертывание кода.
    - Уменьшение количества ошибок: GitOps позволяет обнаруживать
    и исправлять ошибки на ранних этапах, что снижает риск
    критических ошибок в продакшене.
    - Улучшение сотрудничества: GitOps позволяет командам
    работать вместе над конфигурацией и управлением инфраструктурой
    и приложениями, что улучшает сотрудничество и общую картину.

    Недостатки GitOps:
    - Сложность: GitOps требует определенного уровня сложности
    и требует от команд понимания Git, CI/CD и других инструментов.
    - Требуется дополнительные инструменты: GitOps требует использования
    дополнительных инструментов, таких как Git, CI/CD-серверы, агенты и т. д.
    - Требуется время на настройку: GitOps требует времени на настройку
    и конфигурацию, что может занять несколько недель или даже месяцев.
    - Может быть сложно масштабировать: GitOps может быть сложно
    масштабировать для больших и сложных систем, что требует
    дополнительных ресурсов и времени.
    - Требует квалифицированных специалистов: GitOps требует
    квалифицированных специалистов, которые понимают Git, CI/CD
    и другие инструменты, что может быть проблемой для некоторых
    команд.
```

```txt
2 - Каким командам/проектам не подходит этот подход?

->  GitOps не подходит для всех команд и проектов.
    Вот некоторые примеры команд и проектов, для которых
    GitOps может не быть подходящим:

    - Маленькие команды или проекты: GitOps требует
    определенного уровня сложности и времени на настройку,
    что может быть нецелесообразно для маленьких команд или
    проектов.
    - Проекты с простой инфраструктурой: Если инфраструктура
    проекта простая и не требует частых изменений, GitOps
    может быть излишеством.
    - Проекты с ограниченным бюджетом: GitOps требует
    использования дополнительных инструментов и ресурсов,
    что может быть проблемой для проектов с ограниченным
    бюджетом.
    - Команды без опыта работы с Git: GitOps требует от команд
    понимания Git и других инструментов, что может быть проблемой
    для команд без опыта работы с этими инструментами.
    - Проекты с высокими требованиями к безопасности: GitOps
    требует хранения конфигурации и кода в Git, что может быть
    проблемой для проектов с высокими требованиями к безопасности.
    - Проекты с частыми изменениями конфигурации: GitOps требует
    хранения конфигурации в Git, что может быть проблемой для
    проектов с частыми изменениями конфигурации.
    - Проекты с большим количеством ручных процессов: GitOps
    требует автоматизации процессов, что может быть проблемой
    для проектов с большим количеством ручных процессов.
    - Проекты с ограниченным количеством ресурсов: GitOps
    требует использования ресурсов, таких как серверы, агенты
    и т. д., что может быть проблемой для проектов с ограниченным
    количеством ресурсов.

    Примеры команд и проектов, для которых GitOps может
    не быть подходящим:

    - Маленькие веб-студии, разрабатывающие простые веб-сайты
    - Команды, разрабатывающие мобильные приложения с
    простой инфраструктурой
    - Проекты с ограниченным бюджетом, которые не могут
    позволить себе использовать дополнительные инструменты и ресурсы
    - Команды без опыта работы с Git и другими
    инструментами, необходимыми для GitOps
    - Проекты с высокими требованиями к безопасности,
    которые не могут хранить конфигурацию и код в Git

    В целом, GitOps подходит для команд и проектов, которые
    имеют сложную инфраструктуру, требуют автоматизации процессов
    и имеют опыт работы с Git и другими инструментами.
```

### Advanced-3

```txt
1 - Как установить ArgoCD и настроить с его помощью
    деплой в Kubernetes ?

->  Декларативный инструмент непрерывной доставки GitOps для k8s.
    GitOps - всю инфрастуктуру декларативно описывать как код и хранить
    этот код, например, в ветке main. Смотреть на REPO и понимать, что
    задеплоено не взаимодеиствуя с кластером.

    ArgoCD - реализован как контроллер для k8s, отслеживает запущенные
    приложения и сравнивает текущее реальное состояние с целевым
    (желаемым) как указано в репозитории Git. Приложение текущее состояние
    которого отличается от целевого состояния - считается out of sync и
    ArgoCD позволяет автоматически или вручную синхронизировать реальное
    состояние с желаемым состоянием git-репозитория. Любые внесенные
    изменения в желаемое состояния в git-репозитории могут автоматически
    применяться и отражаться в указанных целевых k8s-кластерах. Так же
    ArgoCD может управлять несколькими k8s-кластерами.

    1 - kubectl create namespace argocd
    2 - kubectl apply -f 
    https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    3 - kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
    4 - kubectl port-forward svc/argocd-server -n argocd 8080:443
    5 - kg secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo

```

## <a id="Основные-понятия">Основные понятия</a>

```txt
1 - Понятия виртуализации и контейнеризации, какие проблемы они решают. 
2 - Отличия между виртуализацией и контейнеризацией.
3 - Linux Namespaces.
```

### Notice-4

```txt
1 - Что такое виртуализация? Что такое контейнеризация?

->  Виртуализация - это технология, позволяющая создавать виртуальные
    машины, работающие на физическом сервере. Каждая виртуальная машина
    имеет свой собственный операционную систему и ресурсы.
    
    Контейнеризация - это технология, позволяющая запускать приложения
    в изолированном окружении, без создания виртуальной машины.
    Контейнеры используют общую операционную систему и ресурсы хоста.
```

### Intern-4

```txt
1 - В чём отличия между виртуализацией и контейнеризацией?

->  Отличия: 
    - виртуализация создает виртуальную машину,
    - контейнеризация - изолированное окружение. 
    Виртуализация требует больше ресурсов, контейнеризация - меньше.
    Виртуализация обеспечивает полную изоляцию, контейнеризация - частичную.

    Гипервизор (Hypervisor) - это программное обеспечение, которое
    позволяет создавать и управлять виртуальными машинами (ВМ) на
    физическом компьютере. Гипервизор работает между операционной
    системой и физическим оборудованием, обеспечивая изоляцию и управление
    ресурсами для каждой ВМ.
```

|           |    Виртуализация    |    Контейнеризация    |
| ----------- | ----------- | ----------- |
|    Уровень абстракции    |    Высокий уровень за счет разделения аппаратных ресурсов    |    Низкий уровень. Изолирует ОС и их зависимости    |
|    Изоляция  |    Разделение аппаратных ресурсов за между несколькими ВМ    |    Лучшая изоляция, так как они используют механизмы ядра для разделения ресурсов (память, процессор, устройства)    |
|    Производительность    |    Гипервизор    |    Используется механизм ядра (better)    |
|    Масштабируемость    |    Необходимость перераспределение ресурсов между ВМ    |    Better. Создавать, останавливать, удалять контейнеры без влияния на другие контейнеры    |
|    Управление ресурсами    |    ВМ делать общие ресурсы в рамках компьютера    |    Каждый контейнер имеет свои собственные ресурсы и не влияет на другие контейнеры    |
|    Совместимость    |    Может быть ограничена определенным гипервизовом и ПО    |    Более совместима, так как работает на различных ОС и платформах    |
|    Стоимость    |    Больше ресурсов и оборудования    |    Более экономичное, так как требуется меньше ресурсов и может использоваться на существующем оборудовании    |

```txt
2 - В чем преимущества и недостатки каждого из подходов? 

->  Виртуализация:
    - плюсы - полная изоляция, возможность использования разных
    операционных систем,
    - минусы - высокая нагрузка на ресурсы, сложность управления.
    
    Контейнеризация: 
    - плюсы - низкая нагрузка на ресурсы, простота управления 
    (легкость развертывания, масштабируемость),
    - минусы - не полная изоляция, ограничения в использовании
    ресурсов.
```

### Advanced-4

```txt
1 - На каких механизмах основана работа контейнеризации в Linux?

->  Контейнеризация в Linux основана на механизме Namespaces
    (пространства имён) и Control Groups (группы управления). Namespaces
    позволяют изолировать ресурсы, такие как файловые системы, сокеты и процессы,
    между контейнерами, в то время как Control Groups позволяют ограничивать
    ресурсы, такие как CPU, память и ввод/вывод, для каждого контейнера.
```

```txt
2 - Какие есть типы  Linux Namespaces?

->  - mt (PID) - изоляция процессов: позволяет каждому контейнеру иметь
    свой собственный набор процессов, которые не видны из других контейнеров.
    - mnt (FS) - изоляция файловой системы: позволяет каждому контейнеру
    иметь свой собственный набор монтированных файловых систем, которые
    не видны из других контейнеров.
    - net (Network) - изоляция сетевых ресурсов: позволяет каждому
    контейнеру иметь свой собственный сетевой стек, включая IP-адреса, порты и т. д.
    - ipc (IPC) - изоляция межпроцессного взаимодействия: позволяет
    каждому контейнеру иметь свой собственный набор механизмов
    межпроцессного взаимодействия, таких как сокеты и семафоры.
    - user (UID) - изоляция пользователей: позволяет каждому контейнеру
    иметь свой собственный набор пользователей и групп, которые не видны
    из других контейнеров.
    - uts (Hostname) - изоляция имени хоста: позволяет каждому контейнеру
    иметь свой собственный hostname, который не виден из других контейнеров.
    - cgroup (cgroups) - управление ресурсами: позволяет управлять ресурсами,
    такими как CPU, память и ввод/вывод, для каждого контейнера.
```

```txt
3 -  Как посмотреть список существующих Namespaces?

->  Командой lsns. Эта команда выводит список всех существующих
    Namespaces на хосте. Также можно использовать команду
    nsenter, чтобы войти в конкретный Namespace.
    Опции:
    -t или --type: указывает тип Namespaces, который нужно вывести
    (например, -t pid для вывода только PID Namespaces)
    -u или --uid: указывает UID пользователя, для которого нужно вывести Namespaces
    -g или --gid: указывает GID группы, для которой нужно вывести Namespaces
    -p или --pid: указывает PID процесса, для которого нужно вывести Namespaces
    Примеры использования команды lsns:
    lsns: выводит список всех существующих Namespaces на системе
    lsns -t pid: выводит список только PID Namespaces
    lsns -u 1000: выводит список Namespaces для пользователя с UID 1000
    lsns -p 1234: выводит список Namespaces для процесса с PID 1234
```
