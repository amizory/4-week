# CI/CD - Основы виртуализации и контейнеризации

* [](#)
* [CI/CD в Kubernetes](#CI/CD-в-Kubernetes)
* [GitOps](#GitOps)
* [Основные понятия](#Основные-понятия)

## <a id="CI/CD-в-Kubernetes">CI/CD в Kubernetes</a>

```txt
1 - Стратегии деплоя приложений в Kubernetes.
2 - Helm
```

### Notice-2

```txt
1 - Что такое Helm? Какую проблему он решает? 

->  Helm - это менеджер пакетов для Kubernetes, который упрощает
    процесс установки и управления приложениями в кластере Kubernetes.
    Он решает проблему сложности развертывания и управления приложениями в
    Kubernetes, предоставляя простой и удобный способ установки и
    обновления приложений.

    Helm позволяет:
    - Упаковывать приложения в повторно используемые пакеты (charts)
    - Управлять зависимостями и конфигурацией приложений
    - Упрощать процесс установки и обновления приложений
    - Обеспечивать повторяемость и предсказуемость развертывания приложений

    Это особенно полезно для крупных и сложных приложений, которые состоят
    из множества компонентов и требуют тщательной настройки. Helm помогает упростить
    процесс управления этими приложениями и сделать его более автоматизированным.
```

```txt
2 - Что такое Helm-чарт?

->  Helm-чарт (Helm Chart) - это упакованный пакет приложения, который содержит
    все необходимые ресурсы и конфигурации для развертывания приложения в
    кластере Kubernetes.

    Чарт включает в себя:
    - Манифесты Kubernetes (yaml-файлы), которые описывают ресурсы,
    необходимые для развертывания приложения, такие как деплойменты, сервисы,
    persistent volumes и т.д.
    - Шаблоны конфигурации, которые позволяют настраивать приложение во время
    установки
    - Зависимости и требования к ресурсам, которые необходимы для работы
    приложения
    - Документацию и инструкции по установке, которые помогают пользователям
    понимать, как устанавливать и использовать приложение
    - Версионирование, которое позволяет отслеживать изменения в чарте и
    управлять различными версиями приложения

    Чарты могут быть созданы для конкретного приложения или сервиса, и
    они могут быть легко распространены и установлены в кластере Kubernetes
    с помощью Helm. Это позволяет упростить процесс развертывания и управления
    приложениями в Kubernetes, а также обеспечивает повторяемость и
    предсказуемость развертывания.
```

### Intern-2

```txt
1 - Что такое values-файл в Helm?

->  Values-файл в Helm - это файл, который содержит пользовательские
    значения, которые используются для настройки чарта во время установки.
    Этот файл позволяет пользователю задавать значения для переменных, которые
    используются в шаблонах конфигурации чарта.

    Values-файл обычно имеет расширение .yaml или .yml и содержит
    ключ-значение пары, которые используются для настройки чарта.
    Например, values-файл может содержать значения для таких переменных,
    как:
    - Имя приложения
    - Версия приложения
    - Параметры конфигурации
    - Значения переменных окружения

    Во время установки чарта, Helm использует значения из values-файла для
    замены переменных в шаблонах конфигурации, что позволяет настроить чарт
    в соответствии с потребностями пользователя.
```

```txt
2 - Как использовать переменные в Helm-чартах?  

->  В Helm-чартах переменные можно использовать с помощью синтаксиса
    {{ .Values.имя_переменной }}. Этот синтаксис позволяет получить значение
    переменной из values-файла и использовать его в шаблонах конфигурации.

    metadata:
        name: {{ .Values.appName }}

    Также можно использовать функции шаблонизации, такие как default,
    required и lookup, чтобы работать с переменными в шаблонах конфигурации.

    metadata:
        name: {{ .Values.appName | default "myapp" }}
```

```txt
3 - Как использовать несколько values-файлов при деплое?

->  В Helm можно использовать несколько values-файлов при деплое, чтобы
    разделить конфигурацию на несколько файлов или чтобы использовать
    разные конфигурации для разных окружений.

    - helm install mychart --values values.yaml --values values-prod.yaml
    - helm install mychart -f values.yaml -f values-prod.yaml -f values-override.yaml
```

```txt
4 - Как переопределить при запуске деплоя с помощью
    Helm переменную из values-файла?

->  Чтобы переопределить переменную из values.yaml файла при запуске
    деплоя с помощью Helm, вы можете использовать флаг --set или --set-string
    в команде helm install или helm upgrade.

    helm install my-release my-chart --set image.tag=latest
    helm install my-release my-chart --set-string image.tag="latest-rc"
    helm install my-release my-chart --set image.tag=latest,replicaCount=3
    helm install my-release my-chart -f my-values.yaml

    Если у вас есть values-файл values.yaml с переменной myVariable и вы
    хотите переопределить ее значение на newValue при деплое, вы можете
    использовать следующую команду

    helm upgrade --install my-release . --set myVariable=newValue
    helm upgrade --install my-release . --set values.myVariable=newValue

    В Helm 3 --install и --upgrade объединены в один флаг --install
```

### Advanced-2

```txt
1 - Как перед запуском деплоя с помощью Helm посмотреть
    сгенерированные им манифесты?

->  Helm 2 

    helm install my-release my-chart --dry-run
    Флаг --dry-run используется для генерации манифестов Kubernetes
    без фактического применения их к кластеру. Это означает, что Helm
    будет генерировать манифесты, но не будет создавать ресурсы в кластере.

    helm install my-release my-chart --debug
    Флаг --debug используется для вывода дополнительной информации о
    процессе генерации манифестов и применения их к кластеру. Это означает,
    что Helm будет выводить подробную информацию о том, что происходит во
    время генерации и применения манифестов.
    
    helm install my-release my-chart --dry-run --output-dir ./manifests

    Helm 3
    helm template my-release my-chart
    helm template my-release my-chart --output-dir ./manifests
    helm template my-release my-chart --debug

    В Helm 3 команда helm install и helm upgrade больше не
    поддерживают флаг --dry-run
```

```txt
2 - Как откатиться на предыдущий релиз с помощью Helm?

->  kubectl rollout history
    kubectl rollout status 

    helm history RELEASE
    helm rollback <RELEASE>
    helm rollback my-release 

    Helm хранит историю релизов в кластере Kubernetes, поэтому вы можете
    откатиться на предыдущий релиз даже если вы удалили релиз с помощью
    команды helm uninstall
```

## <a id="GitOps">GitOps</a>

```txt
1 - Понятие GitOps, преимущества и недостатки подхода.
2 - Argo CD
```

### Notice-3

```txt
1 - Что такое GitOps? 

->  GitOps - это подход к управлению инфраструктурой и приложениями,
    который использует Git как основную систему управления конфигурацией.

    GitOps позволяет управлять инфраструктурой и приложениями как кодом,
    используя Git для хранения и управления конфигурацией

    GitOps основан на следующих принципах:
    - Git как основная система управления конфигурацией: Git используется
    для хранения и управления конфигурацией инфраструктуры и приложений.
    - Код как конфигурация: конфигурация инфраструктуры и приложений представлена
    в виде кода, который может быть изменен и управляем как любой другой код.
    - Автоматическое применение конфигурации: конфигурация инфраструктуры
    и приложений автоматически применяется после изменения кода.
    - Мониторинг и аудит: изменения конфигурации инфраструктуры и приложений
    отслеживаются и аудируются для обеспечения прозрачности и безопасности

    GitOps может быть использован для управления различными типами
    инфраструктуры и приложений, включая:
    - Контейнеризированные приложения: GitOps может быть использован
    для управления контейнеризированными приложениями, такими как Docker.
    - Клауд-инфраструктура: GitOps может быть использован для
    управления облачной инфраструктурой, такой как AWS или Azure.
    - Микросервисная архитектура: GitOps может быть использован
    для управления микросервисной архитектурой, такой как Kubernetes.

    GitOps предоставляет следующие преимущества:
    - Упрощенное управление конфигурацией
    - Автоматическое применение конфигурации
    - Повышенная прозрачность и безопасность
    - Улучшенная совместная работа

    Кроме того, GitOps может быть интегрирован с различными инструментами
    и технологиями, такими как:
    - CI/CD: GitOps может быть интегрирован с инструментами CI/CD,
    такими как Jenkins или GitLab CI/CD, для автоматизации процесса
    сборки и развертывания приложений.
    - Мониторинг: GitOps может быть интегрирован с инструментами
    мониторинга, такими как Prometheus или Grafana, для отслеживания
    производительности и состояния инфраструктуры и приложений.
    - Безопасность: GitOps может быть интегрирован с инструментами
    безопасности, такими как Vault или Kubernetes Secrets, для
    управления доступом и шифрования данных.

    В целом, GitOps является мощным инструментом для управления
    инфраструктурой и приложениями, который может помочь упростить
    процесс управления конфигурацией, повысить прозрачность и безопасность,
    и улучшить совместную работу.
```

### Intern-3

```txt
1 - Какие преимущества и недостатки он даёт?

->  GitOps - это подход к управлению инфраструктурой и приложениями
    с помощью Git. Основная идея GitOps заключается в том, чтобы
    использовать Git в качестве единого источника истины для
    конфигурации и управления инфраструктурой и приложениями.

    Преимущества GitOps:
    - Управление конфигурацией: GitOps позволяет хранить
    конфигурацию инфраструктуры и приложений в Git, что
    обеспечивает прозрачность, отслеживание изменений и
    управление версиями.
    - Автоматизация: GitOps позволяет автоматизировать
    процесс развертывания и обновления инфраструктуры и
    приложений, что снижает риск ошибок и увеличивает скорость
    выпуска.
    - Непрерывная интеграция и доставка: GitOps позволяет
    интегрировать процесс непрерывной интеграции и доставки
    (CI/CD) с Git, что обеспечивает автоматизированную сборку,
    тестирование и развертывание кода.
    - Уменьшение количества ошибок: GitOps позволяет обнаруживать
    и исправлять ошибки на ранних этапах, что снижает риск
    критических ошибок в продакшене.
    - Улучшение сотрудничества: GitOps позволяет командам
    работать вместе над конфигурацией и управлением инфраструктурой
    и приложениями, что улучшает сотрудничество и общую картину.

    Недостатки GitOps:
    - Сложность: GitOps требует определенного уровня сложности
    и требует от команд понимания Git, CI/CD и других инструментов.
    - Требуется дополнительные инструменты: GitOps требует использования
    дополнительных инструментов, таких как Git, CI/CD-серверы, агенты и т. д.
    - Требуется время на настройку: GitOps требует времени на настройку
    и конфигурацию, что может занять несколько недель или даже месяцев.
    - Может быть сложно масштабировать: GitOps может быть сложно
    масштабировать для больших и сложных систем, что требует
    дополнительных ресурсов и времени.
    - Требует квалифицированных специалистов: GitOps требует
    квалифицированных специалистов, которые понимают Git, CI/CD
    и другие инструменты, что может быть проблемой для некоторых
    команд.
```

```txt
2 - Каким командам/проектам не подходит этот подход?

->  GitOps не подходит для всех команд и проектов.
    Вот некоторые примеры команд и проектов, для которых
    GitOps может не быть подходящим:

    - Маленькие команды или проекты: GitOps требует
    определенного уровня сложности и времени на настройку,
    что может быть нецелесообразно для маленьких команд или
    проектов.
    - Проекты с простой инфраструктурой: Если инфраструктура
    проекта простая и не требует частых изменений, GitOps
    может быть излишеством.
    - Проекты с ограниченным бюджетом: GitOps требует
    использования дополнительных инструментов и ресурсов,
    что может быть проблемой для проектов с ограниченным
    бюджетом.
    - Команды без опыта работы с Git: GitOps требует от команд
    понимания Git и других инструментов, что может быть проблемой
    для команд без опыта работы с этими инструментами.
    - Проекты с высокими требованиями к безопасности: GitOps
    требует хранения конфигурации и кода в Git, что может быть
    проблемой для проектов с высокими требованиями к безопасности.
    - Проекты с частыми изменениями конфигурации: GitOps требует
    хранения конфигурации в Git, что может быть проблемой для
    проектов с частыми изменениями конфигурации.
    - Проекты с большим количеством ручных процессов: GitOps
    требует автоматизации процессов, что может быть проблемой
    для проектов с большим количеством ручных процессов.
    - Проекты с ограниченным количеством ресурсов: GitOps
    требует использования ресурсов, таких как серверы, агенты
    и т. д., что может быть проблемой для проектов с ограниченным
    количеством ресурсов.

    Примеры команд и проектов, для которых GitOps может
    не быть подходящим:

    - Маленькие веб-студии, разрабатывающие простые веб-сайты
    - Команды, разрабатывающие мобильные приложения с
    простой инфраструктурой
    - Проекты с ограниченным бюджетом, которые не могут
    позволить себе использовать дополнительные инструменты и ресурсы
    - Команды без опыта работы с Git и другими
    инструментами, необходимыми для GitOps
    - Проекты с высокими требованиями к безопасности,
    которые не могут хранить конфигурацию и код в Git

    В целом, GitOps подходит для команд и проектов, которые
    имеют сложную инфраструктуру, требуют автоматизации процессов
    и имеют опыт работы с Git и другими инструментами.
```

### Advanced-3

```txt
1 - Как установить ArgoCD и настроить с его помощью
    деплой в Kubernetes ?

->  Декларативный инструмент непрерывной доставки GitOps для k8s.
    GitOps - всю инфрастуктуру декларативно описывать как код и хранить
    этот код, например, в ветке main. Смотреть на REPO и понимать, что
    задеплоено не взаимодеиствуя с кластером.

    ArgoCD - реализован как контроллер для k8s, отслеживает запущенные
    приложения и сравнивает текущее реальное состояние с целевым
    (желаемым) как указано в репозитории Git. Приложение текущее состояние
    которого отличается от целевого состояния - считается out of sync и
    ArgoCD позволяет автоматически или вручную синхронизировать реальное
    состояние с желаемым состоянием git-репозитория. Любые внесенные
    изменения в желаемое состояния в git-репозитории могут автоматически
    применяться и отражаться в указанных целевых k8s-кластерах. Так же
    ArgoCD может управлять несколькими k8s-кластерами.

    1 - kubectl create namespace argocd
    2 - kubectl apply -f 
    https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    3 - kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
    4 - kubectl port-forward svc/argocd-server -n argocd 8080:443
    5 - kg secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo

```

## <a id="Основные-понятия">Основные понятия</a>

```txt
1 - Понятия виртуализации и контейнеризации, какие проблемы они решают. 
2 - Отличия между виртуализацией и контейнеризацией.
3 - Linux Namespaces.
```

### Notice-4

```txt
1 - Что такое виртуализация? Что такое контейнеризация?

->  Виртуализация - это технология, позволяющая создавать виртуальные
    машины, работающие на физическом сервере. Каждая виртуальная машина
    имеет свой собственный операционную систему и ресурсы.
    
    Контейнеризация - это технология, позволяющая запускать приложения
    в изолированном окружении, без создания виртуальной машины.
    Контейнеры используют общую операционную систему и ресурсы хоста.
```

### Intern-4

```txt
1 - В чём отличия между виртуализацией и контейнеризацией?

->  Отличия: 
    - виртуализация создает виртуальную машину,
    - контейнеризация - изолированное окружение. 
    Виртуализация требует больше ресурсов, контейнеризация - меньше.
    Виртуализация обеспечивает полную изоляцию, контейнеризация - частичную.

    Гипервизор (Hypervisor) - это программное обеспечение, которое
    позволяет создавать и управлять виртуальными машинами (ВМ) на
    физическом компьютере. Гипервизор работает между операционной
    системой и физическим оборудованием, обеспечивая изоляцию и управление
    ресурсами для каждой ВМ.
```

|           |    Виртуализация    |    Контейнеризация    |
| ----------- | ----------- | ----------- |
|    Уровень абстракции    |    Высокий уровень за счет разделения аппаратных ресурсов    |    Низкий уровень. Изолирует ОС и их зависимости    |
|    Изоляция  |    Разделение аппаратных ресурсов за между несколькими ВМ    |    Лучшая изоляция, так как они используют механизмы ядра для разделения ресурсов (память, процессор, устройства)    |
|    Производительность    |    Гипервизор    |    Используется механизм ядра (better)    |
|    Масштабируемость    |    Необходимость перераспределение ресурсов между ВМ    |    Better. Создавать, останавливать, удалять контейнеры без влияния на другие контейнеры    |
|    Управление ресурсами    |    ВМ делать общие ресурсы в рамках компьютера    |    Каждый контейнер имеет свои собственные ресурсы и не влияет на другие контейнеры    |
|    Совместимость    |    Может быть ограничена определенным гипервизовом и ПО    |    Более совместима, так как работает на различных ОС и платформах    |
|    Стоимость    |    Больше ресурсов и оборудования    |    Более экономичное, так как требуется меньше ресурсов и может использоваться на существующем оборудовании    |

```txt
2 - В чем преимущества и недостатки каждого из подходов? 

->  Виртуализация:
    - плюсы - полная изоляция, возможность использования разных
    операционных систем,
    - минусы - высокая нагрузка на ресурсы, сложность управления.
    
    Контейнеризация: 
    - плюсы - низкая нагрузка на ресурсы, простота управления 
    (легкость развертывания, масштабируемость),
    - минусы - не полная изоляция, ограничения в использовании
    ресурсов.
```

### Advanced-4

```txt
1 - На каких механизмах основана работа контейнеризации в Linux?

->  Контейнеризация в Linux основана на механизме Namespaces
    (пространства имён) и Control Groups (группы управления). Namespaces
    позволяют изолировать ресурсы, такие как файловые системы, сокеты и процессы,
    между контейнерами, в то время как Control Groups позволяют ограничивать
    ресурсы, такие как CPU, память и ввод/вывод, для каждого контейнера.
```

```txt
2 - Какие есть типы  Linux Namespaces?

->  - mt (PID) - изоляция процессов: позволяет каждому контейнеру иметь
    свой собственный набор процессов, которые не видны из других контейнеров.
    - mnt (FS) - изоляция файловой системы: позволяет каждому контейнеру
    иметь свой собственный набор монтированных файловых систем, которые
    не видны из других контейнеров.
    - net (Network) - изоляция сетевых ресурсов: позволяет каждому
    контейнеру иметь свой собственный сетевой стек, включая IP-адреса, порты и т. д.
    - ipc (IPC) - изоляция межпроцессного взаимодействия: позволяет
    каждому контейнеру иметь свой собственный набор механизмов
    межпроцессного взаимодействия, таких как сокеты и семафоры.
    - user (UID) - изоляция пользователей: позволяет каждому контейнеру
    иметь свой собственный набор пользователей и групп, которые не видны
    из других контейнеров.
    - uts (Hostname) - изоляция имени хоста: позволяет каждому контейнеру
    иметь свой собственный hostname, который не виден из других контейнеров.
    - cgroup (cgroups) - управление ресурсами: позволяет управлять ресурсами,
    такими как CPU, память и ввод/вывод, для каждого контейнера.
```

```txt
3 -  Как посмотреть список существующих Namespaces?

->  Командой lsns. Эта команда выводит список всех существующих
    Namespaces на хосте. Также можно использовать команду
    nsenter, чтобы войти в конкретный Namespace.
    Опции:
    -t или --type: указывает тип Namespaces, который нужно вывести
    (например, -t pid для вывода только PID Namespaces)
    -u или --uid: указывает UID пользователя, для которого нужно вывести Namespaces
    -g или --gid: указывает GID группы, для которой нужно вывести Namespaces
    -p или --pid: указывает PID процесса, для которого нужно вывести Namespaces
    Примеры использования команды lsns:
    lsns: выводит список всех существующих Namespaces на системе
    lsns -t pid: выводит список только PID Namespaces
    lsns -u 1000: выводит список Namespaces для пользователя с UID 1000
    lsns -p 1234: выводит список Namespaces для процесса с PID 1234
```
